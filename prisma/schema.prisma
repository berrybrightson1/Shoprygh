generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// --- Multi-Tenancy Core ---

model Store {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  tier        StoreTier @default(HUSTLER)
  ownerPhone  String?
  
  // Profile Information
  logo        String?   // URL to logo image
  description String?   // Store bio/description
  address     String?   // Physical business address
  
  // Account Status
  status           StoreStatus @default(ACTIVE)
  suspensionReason String?
  suspendedAt      DateTime?
  termsAcceptedAt  DateTime?
  
  users       User[]
  products    Product[]
  orders      Order[]
  subscriptions Subscription[]
  

  // Finance
  walletBalance Decimal @default(0)
  payouts     PayoutRequest[]
  transactions WalletTransaction[]

  // Marketing
  coupons     Coupon[]
  
  // CRM
  customers   Customer[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// --- CRM Models ---

model Customer {
  id          String   @id @default(cuid())
  name        String?
  email       String?
  phone       String?
  
  totalSpent  Decimal  @default(0)
  totalOrders Int      @default(0)
  lastOrderAt DateTime?
  
  notes       String?  @db.Text
  
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id])
  orders      Order[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([storeId, phone]) // Unique customer per store by phone
  @@unique([storeId, email]) // Unique customer per store by email
}

// --- Marketing Models ---

model Coupon {
  id          String   @id @default(cuid())
  code        String   // e.g., "SUMMER10"
  type        String   @default("PERCENTAGE") // PERCENTAGE, FIXED
  value       Decimal
  
  uses        Int      @default(0)
  maxUses     Int?     // If null, unlimited
  expiresAt   DateTime?
  isActive    Boolean  @default(true)
  
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([storeId, code]) // Code must be unique per store
}

// --- Finance Models ---

model PayoutRequest {
  id          String   @id @default(cuid())
  amount      Decimal
  status      String   @default("PENDING") // PENDING, APPROVED, REJECTED
  
  // Payout Details
  method      String   // "Mobile Money", "Bank Transfer"
  destination String   // Phone number or Account Number
  
  // Admin Logic
  processedAt DateTime?
  adminNote   String?  // Why it was rejected/approved
  
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model WalletTransaction {
  id          String   @id @default(cuid())
  amount      Decimal
  type        String   // SALE, PAYOUT, REFUND, FEE
  description String
  
  referenceId String?  // ID of related Order or Payout
  
  storeId     String
  store       Store    @relation(fields: [storeId], references: [id])
  
  createdAt   DateTime @default(now())
}

model SystemUpdate {
  id        String   @id @default(cuid())
  title     String
  content   String   @db.Text
  version   String
  type      String   @default("UPDATE") // UPDATE, ALERT, MAINTENANCE
  createdAt DateTime @default(now())
}

// --- Application Models ---

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // Hashed
  name      String
  role      String   @default("STAFF") // "OWNER" | "STAFF"
  isPlatformAdmin Boolean @default(false)
  
  storeId   String
  store     Store    @relation(fields: [storeId], references: [id])
  
  createdAt DateTime @default(now())
}

model Product {
  id             String   @id @default(cuid())
  name           String
  description    String?
  image          String?
  
  // Pricing
  priceRetail    Decimal
  priceWholesale Decimal?
  
  // Logistics
  sku            String?
  weight         Float?
  dimensions     String?
  
  // Organization
  category       String   @default("General")
  tags           String?
  stockQty       Int      @default(0)
  
  // Bundle Logic
  isBundle       Boolean  @default(false)
  bundleItems    BundleItem[] @relation("ParentBundle")
  
  // Tenancy
  storeId        String
  store          Store    @relation(fields: [storeId], references: [id])
  
  createdAt      DateTime @default(now())
  orderItems     OrderItem[]
}

model BundleItem {
  id        String  @id @default(cuid())
  
  bundleId  String
  bundle    Product @relation("ParentBundle", fields: [bundleId], references: [id])
  
  productId String  
  // In a real app, we might want to relation to the child Product too, but to keep it simple and avoid circular mess/complex deletes, ID ref is okay. 
  // However, usually better to have a relation if we want to ensure referential integrity.
  // For now I'll keep it as ID based on previous schema, but arguably it should be related. 
  // Let's stick to previous schema style to minimize drift, unless strictly needed.
  
  quantity  Int     @default(1)
}

model Order {
  id        String      @id @default(cuid())
  status    String      @default("PENDING") // PENDING, PAID, DELIVERED, CANCELLED
  customerName String?
  customerPhone String?
  
  // CRM Link (Optional for now, populated on checkout)
  customerId    String?
  customer      Customer? @relation(fields: [customerId], references: [id])
  
  total     Decimal
  items     OrderItem[]
  
  // Tenancy
  storeId   String
  store     Store     @relation(fields: [storeId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id])
  
  productId String
  product   Product @relation(fields: [productId], references: [id])
  
  name      String  // Snapshot in case product changes
  quantity  Int
  price     Decimal // Price at time of purchase
}

model Subscription {
  id                  String   @id @default(cuid())
  storeId             String
  store               Store    @relation(fields: [storeId], references: [id])
  
  tier                StoreTier
  status              SubscriptionStatus @default(ACTIVE)
  
  currentPeriodStart  DateTime
  currentPeriodEnd    DateTime
  
  paymentMethod       String?  // e.g., "Paystack", "Mobile Money"
  paymentReference    String?
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

enum StoreStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
}

enum StoreTier {
  HUSTLER
  PRO
  WHOLESALER
}
