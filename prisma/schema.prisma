generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// --- Multi-Tenancy Core ---

model Store {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  tier        StoreTier @default(HUSTLER)
  ownerPhone  String?
  
  users       User[]
  products    Product[]
  orders      Order[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// --- Application Models ---

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // Hashed
  name      String
  role      String   @default("STAFF") // "OWNER" | "STAFF"
  
  storeId   String
  store     Store    @relation(fields: [storeId], references: [id])
  
  createdAt DateTime @default(now())
}

model Product {
  id             String   @id @default(cuid())
  name           String
  description    String?
  image          String?
  
  // Pricing
  priceRetail    Decimal
  priceWholesale Decimal?
  
  // Logistics
  sku            String?
  weight         Float?
  dimensions     String?
  
  // Organization
  category       String   @default("General")
  tags           String?
  stockQty       Int      @default(0)
  
  // Bundle Logic
  isBundle       Boolean  @default(false)
  bundleItems    BundleItem[] @relation("ParentBundle")
  
  // Tenancy
  storeId        String
  store          Store    @relation(fields: [storeId], references: [id])
  
  createdAt      DateTime @default(now())
  orderItems     OrderItem[]
}

model BundleItem {
  id        String  @id @default(cuid())
  
  bundleId  String
  bundle    Product @relation("ParentBundle", fields: [bundleId], references: [id])
  
  productId String  
  // In a real app, we might want to relation to the child Product too, but to keep it simple and avoid circular mess/complex deletes, ID ref is okay. 
  // However, usually better to have a relation if we want to ensure referential integrity.
  // For now I'll keep it as ID based on previous schema, but arguably it should be related. 
  // Let's stick to previous schema style to minimize drift, unless strictly needed.
  
  quantity  Int     @default(1)
}

model Order {
  id        String      @id @default(cuid())
  status    String      @default("PENDING") // PENDING, PAID, DELIVERED, CANCELLED
  customerName String?
  customerPhone String?
  
  total     Decimal
  items     OrderItem[]
  
  // Tenancy
  storeId   String
  store     Store     @relation(fields: [storeId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id])
  
  productId String
  product   Product @relation(fields: [productId], references: [id])
  
  name      String  // Snapshot in case product changes
  quantity  Int
  price     Decimal // Price at time of purchase
}

enum StoreTier {
  HUSTLER
  PRO
  WHOLESALER
}
